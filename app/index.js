// Generated by CoffeeScript 1.3.3
var Horse, User, UserModel, app, assets, express, fs, gameStarted, getMS, http, io, mongoose, port, runSites, scores, sites, sitesArray, stylus;

express = require('express');

stylus = require('stylus');

assets = require('connect-assets');

http = require('http');

fs = require('fs');

mongoose = require('mongoose');

scores = {};

gameStarted = false;

sites = {
  'Meetup': 'meetup.com',
  'Github': 'github.com',
  'jQuery': 'jquery.com',
  'Yahoo': 'yahoo.com',
  'Underscore': 'underscorejs.org',
  'LoDash': 'lodash.com'
};

sitesArray = [
  {
    name: 'Meetup',
    url: "meetup.com"
  }, {
    name: 'Github',
    url: "github.com"
  }, {
    name: 'jQuery',
    url: "jquery.com"
  }, {
    name: 'Yahoo',
    url: "yahoo.com"
  }, {
    name: 'Underscore',
    url: "underscorejs.org"
  }, {
    name: 'LoDash',
    url: "lodash.com"
  }
];

mongoose.connect('mongodb://localhost/horse');

User = new mongoose.Schema({
  name: {
    type: String,
    "default": 'noob'
  },
  horse: {
    type: String,
    "default": 'meetup.com'
  },
  bet: {
    type: Number,
    "default": -1
  },
  money: {
    type: Number,
    "default": 100
  }
});

Horse = new mongoose.Schema({
  name: {
    type: String,
    "default": 'meetup.com'
  },
  odds: {
    type: String,
    "default": "1/1"
  }
});

UserModel = mongoose.model('User', User);

app = express.createServer();

app.use(assets());

app.use(express["static"](__dirname + '/../public'));

io = require('socket.io').listen(app);

app.get('/', function(req, res) {
  return fs.readFile(__dirname + '/../public/index.html', function(err, data) {
    if (err) {
      console.log(err);
      res.end('Error, 500');
    }
    return res.end(data);
  });
});

app.get('/site/:site', function(req, res) {
  return getMS(req.params.site, function(json) {
    return res.json(json);
  });
});

app.get('/api/v1/horses', function(req, res) {
  return res.json(sitesArray);
});

app.post('/api/v1/name', function(req, res) {
  var u;
  u = new UserModel();
  u.name = req.query.name;
  u.save();
  return res.json(u);
});

app.post('/api/v1/bet', function(req, res) {
  var u;
  u = new UserModel();
  if (gameStarted) {
    res.json({
      error: 'Game Started, sorry!'
    });
  }
  return u.findById(req.query.id, function(err, user) {
    var bet;
    if (!err) {
      bet = req.query.bet;
      if (bet > user.money || bet < 1) {
        res.json({
          error: 'Not enough money!'
        });
      }
      user.horse = req.query.horse;
      user.bet = req.query.bet;
      user.save();
      io.sockets.emit('new_bet', {
        name: data.name,
        horse: data.horse,
        bet: data.bet
      });
      return res.json(user);
    }
  });
});

app.post('/api/v1/endgame', function(req, res) {
  return 0;
});

app.get('/startGamePhish', function(req, res) {
  io.sockets.emit('startGame', true);
  gameStarted = true;
  return runSites(function() {
    return res.json(scores);
  });
});

getMS = function(site, callback) {
  var i, ms, output, start, _results,
    _this = this;
  output = [];
  ms = 0;
  start = 100;
  i = start;
  _results = [];
  while (--i > 0) {
    start = new Date();
    _results.push(http.get({
      host: site,
      port: 80,
      agent: false
    }, function(res) {
      var length;
      length = new Date() - start;
      ms += length;
      output.push({
        message: "Request took: " + length + ("ms (" + site + ")"),
        time: length,
        site: site,
        status: res.statusCode
      });
      if (output.length === 99) {
        return callback(site, ms / 100);
      }
    }));
  }
  return _results;
};

runSites = function(callback) {
  var current, i, s, _results;
  scores = {};
  i = 0;
  _results = [];
  for (s in sites) {
    current = sites[s];
    _results.push(getMS(current, function(title, ms) {
      scores[title] = ms;
      if (++i === 6) {
        return callback();
      }
    }));
  }
  return _results;
};

port = process.env.PORT || process.env.VMC_APP_PORT || 4000;

app.listen(port, function() {
  return console.log("Listening on " + port);
});

io.sockets.on("connection", function(socket) {
  return socket.on("connection", function(data) {
    var u;
    u = new UserModel();
    return u.findById(data.id, function(err, user) {
      var sid;
      if (!err) {
        sid = bet > user.money ? res.json({
          error: 'Not enough money!'
        }) : void 0;
        user.horse = req.query.horse;
        user.bet = req.query.bet;
        user.save();
        return res.json(user);
      }
    });
  });
});
